## ***ipse_staking文档***
***
### 一、模块主要功能概括
* 矿工声明自己参与挖矿，其他人进行抵押（最多64个用户抵押)
> 必须是这个时代去声明下个时代，上个时代的声明是作废了的
* 一个era结束，重新筛选出抵押最高的110位矿工
* 这个时代开始，就对上个时代的抵押结果做一个镜像（用于每次被选中的奖励的分配依据)
* 一旦poc被选中，立马分发奖励
* 不需要去绑定账号（stash与controller)

***
### 数据结构
* 抵押信息
```
struct stking_info {
    矿工id: AccountId,
    矿工分润比：Permill,
    总抵押金额：Balance,
    具体抵押情况：Vec<(AccountId, Balance)>,
}
```
***
* 操作方向
```
enum oprate {
    add, // 增加金额
    sub, // 减少金额
}
```
### ***storage***

* 矿工抵押信息镜像(用于周期结束的奖励依据)： AccountId => stking_info

* 本周期正在进行抵押的信息： AccountId => stking_info,

* 是否在矿工修改信息时间段： bool
    >（在声明期内不能执行抵押相关操作)

* 一个矿工最多多少个抵押：u32

* 矿工个人poc出块信息的统计： AccountId => (stking_info, Balance, BlockNumber)
	> AccountId => (抵押镜像， 奖励金额， 奖励区块)
                                                                    >
* 矿工注册的存储信息： AccountId => 信息（多少容量, 开始的区块)
	> 必须注册信息才能作为poc节点
### 主要方法

1. 抵押人为矿工抵押币(不是选举逻辑，只是你容量上去你就需要抵押相应的币，这是一个特有的经济模型)
    * 不能在矿工修改信息时间段内
    * 矿工也可以给自己抵押
    * 一个矿工最多得到64个人的抵押金额
    * 已经抵押过的不能再抵押

***
2. 抵押人修改抵押
    * 不能在矿工修改信息时间段内
    * 已经抵押过

***
3. 抵押人解除抵押（下个周期开始不算奖励）
    * 不能在矿工修改信息时间段内
    * 自己抵押过


***
4. 矿工修改分润占比
    * 不能在矿工修改信息时间段内
    * 自己是矿工
    * 只有一段时间可以执行

***
5. fn on_initialize(n: T::BlockNumber)
    * 检查是否是矿工修改信息时间段，如果是，把声明变量改成true
***
6. 注册存储信息
    * Event返回矿工id 用于p盘
***
7. 矿工踢掉某个支持者
    * 随时可以踢掉， 但是只是从镜像中删除（因为镜像中才是跟奖励挂钩的）
***
### 辅助方法
1. 根据抵押金额进行排序
2. 奖励被选中的节点
3. 验证p盘的空间是否足够（不够的话只给10个点的收益)


***
### ***抵押与琐仓的逻辑关系***
不需要进行琐仓操作
***
### 如何解决节点被选中的概率计算不准确问题
* 不准确问题刚刚开始的时候肯定是没法解决的，次数不够，不足以用来计算概率。所以刚刚开始时候就当是所有节点都是虚报数据。
* 如果虚报了自己的p盘空间（报高），会导致其他人的收益变小。所以上报空间的作用是为了解决这个问题。
* 只要自己的被选中概率达不到应该达到的，那么就降低它的收益。这个是每次被选中后去计算的，实时，动态（为了准确反映情况)。

* 考虑到有些时候数据不怎么准确，所以允许10个点的偏差
* 可以考虑刚开始的时候给50个点的收益，当p盘时间达到一定高度后（比如poc出块1000次后)开始计算概率
### 概率计算注意点
* 本账户被选中的概率 = 上次更新盘信息到目前为止该矿工被选中的总次数 / 该矿工作为poc节点时全网总共poc出块总数
	> 注意：这里必须是该用户作为poc节点时全网总共poc出块总数， 这个才是准确的
* 提醒用户不要频繁更改信息，因为会导致计算概率出现不准确的问题， 影响到收益。



